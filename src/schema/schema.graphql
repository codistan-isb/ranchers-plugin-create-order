extend type Order {
  _id: ID
  id: ID
  startTime: String
  endTime: String
  OrderStatus: OrderStatusValue
  deliveryTime: Float
  OrderID: String
  username: String
  branches: String
  riderID: String
  deliveryTime: Float
  "branch Info Displayed"
  branchInfo: Branch
  Notes: String
  riderInfo: Account
  customerInfo: customerInfoPayload
  rejectionReason: String
  customerOrderTime: customerOrderTimePayload
  branchTimePickup: branchTimePickupPayload
  kitchenOrderIDInfo: kitchenOrderIDPayload
  riderOrderInfo: riderOrderInfoPayload
  Latitude: Float
  Longitude: Float
  # customerOrderInfo:customerOrderInfoPayload
}

type riderOrderInfoPayload {
  _id: ID
  startTime: DateTime
  OrderStatus: String
  OrderID: String
  branches: String
  riderID: String
  createdAt: DateTime
  endTime: DateTime
}
# type customerOrderInfoPayload{

# }
type OrderReport {
  _id: ID
  riderID: String
  riderName: String
  branchCity: String
  branches: String
  OrderStatus: OrderStatusValue
  deliveryTime: String
  startTime: String
  endTime: String
  username: String
  OrderID: String
  # "branch Info Displayed"implements Node
  branchInfo: Branch
  rejectionReason: String
  customerInfo: customerInfoPayload
  kitchenOrderIDInfo: kitchenOrderIDPayload
  riderInfo: Account
  orderDetailTime: orderDetailTimePayload
}
type orderDetailTimePayload {
  prepTime: Int
  deliveryTime: Float
}
# type OrderReportEdge implements NodeEdge {
#   "The cursor that represents this node in the paginated results"
#   cursor: ConnectionCursor!
#   "The Order Report"
#   node: OrderReport
# }
# type OrderReportConnection {
#   "The list of nodes that match the query, wrapped in an edge to provide a cursor string for each"
#   edges: [OrderReportEdge]
#   """
#   You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
#   if you know you will not need to paginate the results.
#   """
#   nodes: [OrderReport]
#   "Information to help a client request the next or previous page"
#   pageInfo: PageInfo!
#   "The total number of nodes that match your query"
#   totalCount: Int!
# }
extend type Address {
  Latitude: Float
  Longitude: Float
}
type customerInfoPayload {
  fullName: String
  phone: String
  address1: String
  city: String
  country: String
  postal: String
  region: String
}
type customerOrderTimePayload {
  customerOrderTime: DateTime
  Latitude: Float
  Longitude: Float
}
type branchTimePickupPayload {
  branchOrderTime: DateTime
}
type kitchenOrderIDPayload {
  kitchenOrderID: String
}
# type BranchOrderReport {
#   b_id: ID
#   branchAccountId: ID
#   branchCartId: ID
#   branchCreatedAt: String
#   branchCurrencyCode: String
#   branchEmail: String
#   branchOrdererPreferredLanguage: String
#   branchPayments: [Payment]
#   branchShipping: [Shipping]
# }
type UserCurrentStatus {
  _id: ID
  currentStatus: UserStatus
  updatedAt: String
  UserRole: UserRoleValue
  username: String
  branchCity: String
  branches: [String]
}
enum OrderStatusValue {
  "Preparing your meal"
  processing

  "We're all set"
  confirmed

  " The food's ready to ride"
  ready

  "Your meal is picked up"
  pickedUp

  "delivered order"
  delivered

  "Canceled order"
  canceled

  "For new order"
  new

  "Reject Order"
  reject
}
enum UserRoleValue {
  admin
  dispatcher
  rider
}
enum UserStatus {
  online
  offline
}
# type branchOwnerReportOutput {
#   _id: ID
#   accountId: String
#   cartId: String
#   createdAt:String
#   currencyCode: String
#   email: String
# }
type UserAccountDetail {
  _id: ID!
  username: String
  branch: [String!]!
}
type UserBranchData {
  _id: ID!
  branches: [String]
}
type RiderOrderDetail {
  OrderID: ID
  startTime: String
  endTime: String
  OrderStatus: OrderStatusValue
  branches: String
  username: String
}
input NewRiderOrderInput {
  startTime: String
  endTime: String
  OrderStatus: OrderStatusValue!
  OrderID: String
  branches: ID!
  riderID: String
  oldRiderID: String
}

type Mutation {
  createRiderOrder(orders: [NewRiderOrderInput]): Order
  updateRiderOrder(
    id: ID
    startTime: String
    endTime: String
    OrderStatus: OrderStatusValue
    OrderID: String!
    riderID: String!
    rejectionReason: String
  ): Order
  updateUserCurrentStatus(status: UserStatus!): UserCurrentStatus
  assignBranchtoUser(userID: ID!, branches: String!): UserBranchData!
  updateAccountAdmin(userID: ID!, branches: String!): UserBranchData!
  addBranchNotes(orderId: ID!, Notes: String!): Order
}
# enum OrderReportSortBy {
#   startTime
#   createdAt
#   updatedAt
# }
type Query {
  getOrderById(id: ID!): [Order]
  getOrdersByStatus(OrderStatus: OrderStatusValue!): [Order]
  generateOrderReport(
    branches: String
    startTime: String
    endTime: String
    riderID: String
    OrderID: String
    fromDate: DateTime
    toDate: DateTime
    deliveryTime: Float
  ): [OrderReport]

  # generateOrderReport(
  #   branches: String
  #   startTime: DateTime
  #   endTime: DateTime
  #   riderID: String
  #   OrderID: String
  #   fromDate: DateTime
  #   toDate: DateTime
  #   deliveryTime: Float
  # searchQuery: String
  "Return only results that come after this cursor. Use this with `first` to specify the number of results to return."
  # after: ConnectionCursor
  # "Return only results that come before this cursor. Use this with `last` to specify the number of results to return."
  # before: ConnectionCursor
  # "Return at most this many results. This parameter may be used with either `after` or `offset` parameters."
  # first: ConnectionLimitInt
  # "Return at most this many results. This parameter may be used with the `before` parameter."
  # last: ConnectionLimitInt
  # "Return only results that come after the Nth result. This parameter may be used with the `first` parameter."
  # offset: Int
  # "Return results sorted in this order"
  # sortOrder: SortOrder = desc
  # "By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields"
  # sortBy: OrderReportSortBy = startTime  #  OrderReportConnection!

  # ): OrderReport
  getRiderOrdersByLoginRider(
    LoginRiderID: String! # startDate: String # endDate: String
  ): [RiderOrderDetail]
  getKitchenReport(
    branchID: String
    OrderStatus: OrderStatusValue
    startDate: String
    endDate: String
  ): [Order]
  getCustomerOrderbyID(ID: ID!): Order
}
